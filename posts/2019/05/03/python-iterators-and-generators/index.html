<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta name=author content="Dacio Romero"><meta name=description content="Photo by John Matychuk on Unsplash
The Problem    While learning at Make School I&rsquo;ve seen my peers write functions that create lists of items.
s = 'baacabcaab' p = 'a'  def find_char(string, character):  indices = list()   for index, str_char in enumerate(string):  if str_char == character:  indices.append(index)   return indices  print(find_char(s, p)) # [1, 2, 4, 7, 8] This implementation works, but it poses a few problems:"><meta name=keywords content="blog,developer"><meta name=twitter:card content="summary"><meta name=twitter:title content="Fantastic Iterators and How to Make Them"><meta name=twitter:description content="Photo by John Matychuk on Unsplash
The Problem    While learning at Make School I&rsquo;ve seen my peers write functions that create lists of items.
s = 'baacabcaab' p = 'a'  def find_char(string, character):  indices = list()   for index, str_char in enumerate(string):  if str_char == character:  indices.append(index)   return indices  print(find_char(s, p)) # [1, 2, 4, 7, 8] This implementation works, but it poses a few problems:"><meta property="og:title" content="Fantastic Iterators and How to Make Them"><meta property="og:description" content="Photo by John Matychuk on Unsplash
The Problem    While learning at Make School I&rsquo;ve seen my peers write functions that create lists of items.
s = 'baacabcaab' p = 'a'  def find_char(string, character):  indices = list()   for index, str_char in enumerate(string):  if str_char == character:  indices.append(index)   return indices  print(find_char(s, p)) # [1, 2, 4, 7, 8] This implementation works, but it poses a few problems:"><meta property="og:type" content="article"><meta property="og:url" content="https://dacio.dev/posts/2019/05/03/python-iterators-and-generators/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-05-03T00:32:00-07:00"><meta property="article:modified_time" content="2019-05-03T00:32:00-07:00"><title>Fantastic Iterators and How to Make Them · Dacio Romero</title><link rel=canonical href=https://dacio.dev/posts/2019/05/03/python-iterators-and-generators/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.93c41bf1e522f85ecda7355985f09000f71fc1d64dda9f74051b0fa06210e93f.css integrity="sha256-k8Qb8eUi+F7NpzVZhfCQAPcfwdZN2p90BRsPoGIQ6T8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.f37febc669ce189201c1918fac1948a254686c8d366a312c2d72b2bb71ad97d1.css integrity="sha256-83/rxmnOGJIBwZGPrBlIolRobI02ajEsLXKyu3Gtl9E=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><meta name=generator content="Hugo 0.98.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Dacio Romero</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://dacio.dev/posts/2019/05/03/python-iterators-and-generators/>Fantastic Iterators and How to Make Them</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2019-05-03T00:32:00-07:00>May 3, 2019</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
7-minute read</span></div></div></header><div><p><img src=https://source.unsplash.com/dJdcb11aboQ alt="Hero Image">
Photo by John Matychuk on Unsplash</p><h2 id=the-problem>The Problem
<a class=heading-link href=#the-problem><i class="fa fa-link" aria-hidden=true></i></a></h2><p>While learning at Make School I&rsquo;ve seen my peers write functions that create lists of items.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;baacabcaab&#39;</span>
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;a&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_char</span>(string, character):
</span></span><span style=display:flex><span>  indices <span style=color:#f92672>=</span> list()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> index, str_char <span style=color:#f92672>in</span> enumerate(string):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> str_char <span style=color:#f92672>==</span> character:
</span></span><span style=display:flex><span>      indices<span style=color:#f92672>.</span>append(index)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> indices
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(find_char(s, p)) <span style=color:#75715e># [1, 2, 4, 7, 8]</span>
</span></span></code></pre></div><p>This implementation works, but it poses a few problems:</p><ul><li>What if we only want the first result; will we need to make an entirely new function?</li><li>What if all we do is loop over the result once, do we need to store every element in memory?</li></ul><p>Iterators are the ideal solution to these problems. They function like &ldquo;lazy lists&rdquo; in that instead of returning a list with every value it produces and returns each element one at a time.</p><blockquote><p>Iterators <strong>lazily</strong> return values; saving memory.</p></blockquote><p><strong><em>So let&rsquo;s dive into learning about them!</em></strong></p><h2 id=built-in-iterators>Built-In Iterators
<a class=heading-link href=#built-in-iterators><i class="fa fa-link" aria-hidden=true></i></a></h2><p>The iterators that are most often are <code>enumerate()</code>, and <code>zip()</code>. Both of these <em>lazily</em> return values by <code>next()</code> with them.</p><p><strong><code>range()</code>, however, is <em>not</em> an iterator, but an <em>&ldquo;lazy iterable.&rdquo;</em></strong> - <a href=https://treyhunner.com/2018/02/python-range-is-not-an-iterator/>Explanation</a></p><p>We can convert <code>range()</code> into an iterator with <code>iter()</code>, so we&rsquo;ll do that for our examples for the sake of learning.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>my_iter <span style=color:#f92672>=</span> iter(range(<span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span>print(next(my_iter)) <span style=color:#75715e># 0</span>
</span></span><span style=display:flex><span>print(next(my_iter)) <span style=color:#75715e># 1</span>
</span></span></code></pre></div><p>Upon each call of <code>next()</code>we get the next value in our range; makes sense right? If you want to convert an iterator it to a list you just give it the list constructor.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>my_iter <span style=color:#f92672>=</span> iter(range(<span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span>print(list(my_iter)) <span style=color:#75715e># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</span></span></code></pre></div><p>If we mimic this behavior we&rsquo;ll start to understand more about how iterators work.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>my_iter <span style=color:#f92672>=</span> iter(range(<span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span>my_list <span style=color:#f92672>=</span> list()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>    my_list<span style=color:#f92672>.</span>append(next(my_iter))
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> <span style=color:#a6e22e>StopIteration</span>:
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(my_list) <span style=color:#75715e># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</span></span></code></pre></div><p>You can see that we needed to wrap it in a try catch statement. That&rsquo;s because iterators raise <code>StopIteration</code> when they&rsquo;ve been exhausted.</p><p>So if we call next on our exhausted range iterator, we&rsquo;ll get that error.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>next(my_iter) <span style=color:#75715e># Raises: StopIteration</span>
</span></span></code></pre></div><h2 id=making-an-iterator>Making an Iterator
<a class=heading-link href=#making-an-iterator><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Let&rsquo;s try making an iterator that behaves like <code>range</code> with only the stop argument by using three common types of iterators: <a href=#class>Classes</a>, <a href=#generator-function>Generator Functions (Yield)</a> and <a href=#generator-expression>Generator Expressions</a></p><h3 id=class>Class
<a class=heading-link href=#class><i class="fa fa-link" aria-hidden=true></i></a></h3><p>The old way of creating an iterator was through an explicitly defined class. For an object to be an iterator it must implement <code>__iter__()</code> that returns itself and <code>__next__()</code> which returns the next value.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>my_range</span>:
</span></span><span style=display:flex><span>  _current <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> __init__(self, stop):
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>_stop <span style=color:#f92672>=</span> stop
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> __iter__(self):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> self
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> __next__(self):
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>_current <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>_current <span style=color:#f92672>&gt;=</span> self<span style=color:#f92672>.</span>_stop:
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>StopIteration</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>_current
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>r <span style=color:#f92672>=</span> my_range(<span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>print(list(r)) <span style=color:#75715e># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</span></span></code></pre></div><p>That wasn&rsquo;t too hard, but unfortunately, we have to keep track of variables between calls of <code>next()</code>. Personally, I don&rsquo;t like the boilerplate or changing how I think about loops because it isn&rsquo;t a drop-in solution, so I prefer <a href=#generators>generators</a></p><p>The main benefit is that we can add additional functions that modify its internal variables such as <code>_stop</code> or create new iterators.</p><blockquote><p>Class iterators have the downside of needing boilerplate, however, they can have additional functions that modify state.</p></blockquote><h3 id=generators>Generators
<a class=heading-link href=#generators><i class="fa fa-link" aria-hidden=true></i></a></h3><p><a href=https://www.python.org/dev/peps/pep-0255/>PEP 255</a> introduced &ldquo;simple generators&rdquo; using the <code>yield</code> keyword.</p><blockquote><p>Today, generators are iterators that are just easier to make than their class counterparts.</p></blockquote><h4 id=generator-function>Generator Function
<a class=heading-link href=#generator-function><i class="fa fa-link" aria-hidden=true></i></a></h4><p>Generator functions are what was ultimately being discussed in that PEP and are my favorite type of iterator, so let&rsquo;s start with that.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>my_range</span>(stop):
</span></span><span style=display:flex><span>  index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> index <span style=color:#f92672>&lt;</span> stop:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> index
</span></span><span style=display:flex><span>    index <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>r <span style=color:#f92672>=</span> my_range(<span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>print(list(r)) <span style=color:#75715e># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</span></span></code></pre></div><p>Do you see how beautiful those 4 lines of code are? It&rsquo;s slightly significantly shorter than our list implementation to top it off!</p><blockquote><p>Generator functions iterators with less boilerplate than classes with a normal logic flow.</p></blockquote><p>Generator functions automagically <strong>&ldquo;pause&rdquo;</strong> execution and return the specified value with every call of <code>next()</code>. This means that <em>no code</em> is run until the <strong>first</strong> <code>next()</code> call.</p><p>This means the flow is like this:</p><ol><li><code>next()</code> is called,</li><li>Code is executed up to the next <code>yield</code> statement.</li><li>The value on the right of <code>yield</code> is returned.</li><li>Execution is paused.</li><li>1-5 repeat for every <code>next()</code> call until the last line of code is hit.</li><li><code>StopIteration</code> is raised.</li></ol><p>Generator functions also allow for you to use the <code>yield from</code> keyword which future <code>next()</code> calls to another iterable until said iterable has been exhausted.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>yielded_range</span>():
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>yield from</span> my_range(<span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(list(yielded_range())) <span style=color:#75715e># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</span></span></code></pre></div><p>That wasn&rsquo;t a particularly complex example. But you can even do it <em>recursively</em>!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>my_range_recursive</span>(stop, current <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>):
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> current <span style=color:#f92672>&gt;=</span> stop:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>yield</span> current
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>yield from</span> my_range_recursive(stop, current <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>r <span style=color:#f92672>=</span> my_range_recursive(<span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>print(list(r)) <span style=color:#75715e># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</span></span></code></pre></div><h4 id=generator-expression>Generator Expression
<a class=heading-link href=#generator-expression><i class="fa fa-link" aria-hidden=true></i></a></h4><p>Generator expressions allow us to create iterators as one-liners and are good when we don&rsquo;t need to give it external functions. Unfortunately, we can&rsquo;t make another <code>my_range</code> using an expression, but we can work on iterables like our last <code>my_range</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>my_doubled_range_10 <span style=color:#f92672>=</span> (x <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> my_range(<span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span>print(list(my_doubled_range_10)) <span style=color:#75715e># 0, 2, 4, 6, 8, 10, 12, 14, 16, 18]</span>
</span></span></code></pre></div><p>The cool thing about this is that it does the following:</p><ol><li>The <code>list</code> asks <code>my_doubled_range_10</code> for its next value.</li><li><code>my_doubled_range_10</code> asks <code>my_range</code> for its next value.</li><li><code>my_doubled_range_10</code> returns <code>my_range</code>&rsquo;s value multiplied by 2.</li><li>The <code>list</code> appends the value to itself.</li><li>1-5 repeat until <code>my_doubled_range_10</code> raises <code>StopIteration</code> which happens when <code>my_range</code> does.</li><li>The <code>list</code> is returned containing each value returned by <code>my_doubled_range</code>.</li></ol><p>We can even do <em>filtering</em> using generator expressions!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>my_even_range_10 <span style=color:#f92672>=</span> (x <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> my_range(<span style=color:#ae81ff>10</span>) <span style=color:#66d9ef>if</span> x <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>print(list(my_even_range_10)) <span style=color:#75715e># [0, 2, 4, 6, 8]</span>
</span></span></code></pre></div><p>This is very similar to the previous except <code>my_even_range_10</code> only returns values that match the given condition, so only even values between in the range [0, 10).</p><p>Throughout all of this, we only create a list because we told it to.</p><h2 id=the-benefit>The Benefit
<a class=heading-link href=#the-benefit><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Because generators are iterators, iterators are iterables, and iterators lazily return values. This means that using this knowledge we can create objects that will only give us objects when we ask for them and however many we like.</p><p>This means we can pass generators into functions that reduce each other.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>print(sum(my_range(<span style=color:#ae81ff>10</span>))) <span style=color:#75715e># 45</span>
</span></span></code></pre></div><p>Calculating the sum in this way avoids creating a list when all we&rsquo;re doing is adding them together and then discarding.</p><p>We can rewrite the very <a href=#the-problem>first example</a> to be much better using a generator function!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;baacabcaab&#39;</span>
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;a&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_char</span>(string, character):
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> index, str_char <span style=color:#f92672>in</span> enumerate(string):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> str_char <span style=color:#f92672>==</span> character:
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>yield</span> index
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(list(find_char(s, p))) <span style=color:#75715e># [1, 2, 4, 7, 8]</span>
</span></span></code></pre></div><p>Now immediately there might be no obvious benefit, but let&rsquo;s go to my first question: &ldquo;what if we only want the first result; will we need to make an entirely new function?&rdquo;</p><blockquote><p>With a generator function we don&rsquo;t need to rewrite as much logic.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>print(next(find_char(s, p))) <span style=color:#75715e># 1</span>
</span></span></code></pre></div><p>Now we <em>could</em> retrieve the first value of the list that our original solution gave, but this way we only get the first match and stop iterating over the list. The generator will be then discarded and nothing else is created; massively saving memory.</p><h2 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa fa-link" aria-hidden=true></i></a></h2><p>If you&rsquo;re ever creating a function the accumulates values in a list like this.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(bar):
</span></span><span style=display:flex><span>  values <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> bar:
</span></span><span style=display:flex><span>    <span style=color:#75715e># some logic</span>
</span></span><span style=display:flex><span>    values<span style=color:#f92672>.</span>append(x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> values
</span></span></code></pre></div><p>Consider making it return an iterator with a class, generator function, or generator expression like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(bar):
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> bar:
</span></span><span style=display:flex><span>    <span style=color:#75715e># some logic</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> x
</span></span></code></pre></div><h2 id=resources-and-sources>Resources and Sources
<a class=heading-link href=#resources-and-sources><i class="fa fa-link" aria-hidden=true></i></a></h2><h4 id=peps>PEPs
<a class=heading-link href=#peps><i class="fa fa-link" aria-hidden=true></i></a></h4><ul><li><a href=https://www.python.org/dev/peps/pep-0255/>Generators</a></li><li><a href=https://www.python.org/dev/peps/pep-0289/>Generator Expressions PEP</a></li><li><a href=https://www.python.org/dev/peps/pep-0380/>Yield From PEP</a></li></ul><h2 id=articles-and-threads>Articles and Threads
<a class=heading-link href=#articles-and-threads><i class="fa fa-link" aria-hidden=true></i></a></h2><ul><li><a href=https://www.programiz.com/python-programming/iterator>Iterators</a></li><li><a href=https://www.geeksforgeeks.org/python-difference-iterable-iterator/>Iterable vs Iterator</a></li><li><a href=https://wiki.python.org/moin/Generator>Generator Documentation</a></li><li><a href=https://nvie.com/posts/iterators-vs-generators/>Iterators vs Generators</a></li><li><a href=https://stackoverflow.com/a/1995585>Generator Expression vs Function</a></li><li><a href=https://stackoverflow.com/a/8991864>Recrusive Generators</a></li></ul><h3 id=definitions>Definitions
<a class=heading-link href=#definitions><i class="fa fa-link" aria-hidden=true></i></a></h3><ul><li><a href=https://docs.python.org/3/glossary.html#term-iterable>Iterable</a></li><li><a href=https://docs.python.org/3/glossary.html#term-iterator>Iterator</a></li><li><a href=https://docs.python.org/3/glossary.html#term-generator>Generator</a></li><li><a href=https://docs.python.org/3/glossary.html#term-generator-iterator>Generator Iterator</a></li><li><a href=https://docs.python.org/3/glossary.html#term-generator-expression>Generator Expression</a></li></ul></div><footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//dacio.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></section></div><footer class=footer><section class=container>©
2019 -
2022
Dacio Romero</section></footer></main><script src=/js/coder.min.f48f8b52310e1a89d74558ac6718cde27d388efc7f13bd1cec79598a4fadce38.js integrity="sha256-9I+LUjEOGonXRVisZxjN4n04jvx/E70c7HlZik+tzjg="></script></body></html>