<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dacio's Tech Blog</title><link>https://blog.dacio.dev/</link><description>Recent content on Dacio's Tech Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 15 May 2019 09:33:28 -0700</lastBuildDate><atom:link href="https://blog.dacio.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Python Memory Management</title><link>https://blog.dacio.dev/posts/2019/05/15/python-memory/</link><pubDate>Wed, 15 May 2019 09:33:28 -0700</pubDate><guid>https://blog.dacio.dev/posts/2019/05/15/python-memory/</guid><description>Photo by Tim Gouw on Unsplash
Managing Memory An assignment that Jasmine and I had recently done for my instructor, Alan Davis, at Make School was given a large list of phone routes consisting of their standardized prefixes and costs.
The task was for increasing amounts of routes and phone numbers to find the longest matches and their prices.
Project Readme
Attempts List One being performing linear search on a list of phone numbers because I couldn&amp;rsquo;t figure out a way to perform binary search.</description></item><item><title>Getting to Refactoring</title><link>https://blog.dacio.dev/posts/2019/05/07/refactoring/</link><pubDate>Tue, 07 May 2019 14:07:22 -0700</pubDate><guid>https://blog.dacio.dev/posts/2019/05/07/refactoring/</guid><description>Photo by Annie Spratt on Unsplash
Every developer at some point will revisit their old project or snippet of code and be disgusted with the work they had. It is natural though: the name of the game as a developer is to continually learn and improve, so looking at old code is almost always when you didn&amp;rsquo;t know as much as you do now.
At first, you might want to avoid messing with old code, but you&amp;rsquo;re missing out an opportunity to learn, improve the maintainability of the code, make it more performant, or even make it a better portfolio item if it&amp;rsquo;s something you can show publicly.</description></item><item><title>Fantastic Iterators and How to Make Them</title><link>https://blog.dacio.dev/posts/2019/05/03/python-iterators-and-generators/</link><pubDate>Fri, 03 May 2019 00:32:00 -0700</pubDate><guid>https://blog.dacio.dev/posts/2019/05/03/python-iterators-and-generators/</guid><description>Photo by John Matychuk on Unsplash
The Problem While learning at Make School I&amp;rsquo;ve seen my peers write functions that create lists of items.
s = &amp;#39;baacabcaab&amp;#39; p = &amp;#39;a&amp;#39; def find_char(string, character): indices = list() for index, str_char in enumerate(string): if str_char == character: indices.append(index) return indices print(find_char(s, p)) # [1, 2, 4, 7, 8] This implementation works, but it poses a few problems:
What if we only want the first result; will we need to make an entirely new function?</description></item><item><title>Hello, World!</title><link>https://blog.dacio.dev/posts/2019/04/10/hello-world/</link><pubDate>Wed, 10 Apr 2019 00:40:00 -0700</pubDate><guid>https://blog.dacio.dev/posts/2019/04/10/hello-world/</guid><description>This is my first post made with Jekyll and hopefully the start of a breat blog!
The Plan I plan to write about the latest technologies that I&amp;rsquo;ve been working on as well as useful tips.
Where I&amp;rsquo;m At I can program in with Python, JavaScript, C#, and Java.
Right now I make websites using React and NodeJS.
I&amp;rsquo;m pretty comfortable with Docker and GitLab CI.
Goals for the end of the year I want to</description></item></channel></rss>